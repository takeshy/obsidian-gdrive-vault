# Obsidian GDrive Vaultプラグイン

ObsidianのVaultをGoogle Driveに同期する手動同期プラグインです。

## 機能

- **手動同期**: 好きなタイミングでPush/Pull
- **安全な同期**: 古いバージョンを保持して復元可能
- **競合解決**: マークダウンファイルのSide-by-side diff表示
- **クロスプラットフォーム**: デスクトップ、Android、iOSで動作
- **多言語対応**: 英語・日本語UI

## インストール

このプラグインには自分のOAuthサーバーが必要です。

### 1. OAuthサーバーをデプロイ

詳細は[obsidian-oauth/README_ja.md](obsidian-oauth/README_ja.md)を参照。

1. Google Cloud Projectを作成
2. OAuth同意画面と認証情報を設定
3. Google App Engineにデプロイ

### 2. プラグインをビルド

1. このリポジトリをフォーク
2. `config.ts`にOAuthサーバーURLを設定:
   ```typescript
   export const OAUTH_CONFIG = {
     refreshAccessTokenURL: "https://YOUR_PROJECT.appspot.com/auth/obsidian/refresh-token",
     fetchRefreshTokenURL: "https://YOUR_PROJECT.appspot.com/auth/obsidian",
   };
   ```
3. mainブランチにpush（GitHub Actionがリリースを作成）

### 3. BRATでインストール

1. コミュニティプラグインから[BRAT](https://github.com/TfTHacker/obsidian42-brat)をインストール
2. BRAT設定を開き「Add Beta plugin」をクリック
3. フォークのURLを入力: `https://github.com/YOUR_USERNAME/obsidian-gdrive-vault`
4. 「Add Plugin」をクリック

### 手動インストール

1. フォークのReleasesから`main.js`と`manifest.json`をダウンロード
2. `.obsidian/plugins/obsidian-gdrive-vault/`フォルダを作成
3. ファイルをコピー
4. Obsidian設定でプラグインを有効化

## セットアップ

1. プラグイン設定を開きログインリンクをクリック
2. Googleアカウントでサインインし権限を許可
3. Refresh Tokenをコピーして設定に貼り付け
4. プラグインを再読み込み
5. 「Initialize vault」をクリックしてGoogle DriveにVaultフォルダを作成

![初期設定](initial_setting.png)

追加デバイスの場合:
1. 同じ名前のVaultを作成
2. フォークからプラグインをインストール
3. 同じGoogleアカウントで設定
4. **Pull Changes**で全ファイルをダウンロード

## コマンド

| コマンド | 説明 |
|----------|------|
| **Push Changes** | ローカルの変更をアップロード（差分） |
| **Pull Changes** | リモートの変更をダウンロード（差分） |
| **Full Push** | Vault全体をアップロード（バックアップ付き） |
| **Full Pull** | Vault全体をダウンロード（バックアップ付き） |

リボンボタン: アップロードアイコン = Push、ダウンロードアイコン = Pull

---

## 一時同期

Push/Pullのオーバーヘッドなしでファイルをさっと共有できます。以下の場合に便利:
- Push/Pullに時間がかかる
- 競合解決を避けたい
- 単一ファイルをデバイス間で素早く共有したい

| コマンド | 説明 |
|----------|------|
| **Temporary upload current file** | アクティブファイルを一時ストレージにアップロード |
| **Temporary download to current file** | 一時ストレージからアクティブファイルにダウンロード |

**ヒント**: Obsidian設定 → ホットキーでショートカットを割り当てると便利です。

**一時ファイルの管理**: 設定 → 一時同期 → 一時ファイルを管理（選択してダウンロードまたは削除）

### 仕組み

- ファイルはGoogle Driveに`__TEMP__/`プレフィックス付きで保存
- **メタファイルは更新されない**（ローカル・リモートどちらも）
- 両端末で同じ編集を手動で行ったのと同等

---

## 同期の仕組み

### 概要

プラグインはメタデータファイルでファイル状態を追跡します:
- **ローカルメタ**: `.obsidian/gdrive-vault-meta.json`
- **リモートメタ**: `_gdrive-vault-meta.json`（Google Drive上）

各メタファイルの内容:
- `lastUpdatedAt`: 最後の同期タイムスタンプ
- `files`: 各ファイルのハッシュと更新時刻

---

## Push Changes（差分）

変更されたファイルのみローカルからリモートにアップロードします。

### フロー

1. **前提条件チェック**
   - リモートメタなし → Full Push
   - ローカルメタなし → エラー: 「先にPullが必要」
   - リモートがローカルより新しい → ダイアログ: 「Pullが必要です」[今すぐPull]ボタン

2. **差分計算**（各ファイル）
   - 比較: 保存メタ vs 実ファイル

3. **変更ファイルをアップロード**

### 前提条件

| ローカルメタ | リモートメタ | リモートが新しい | アクション |
|:----------:|:-----------:|:---------------:|--------|
| - | - | - | Full Push（初回同期） |
| - | あり | - | エラー「先にPullが必要」 |
| あり | あり | Yes | ダイアログ「Pullが必要」 |
| あり | あり | No | Pushを実行 |

### 判定表

前提条件を通過後、保存ローカルメタ = リモートメタ（同期済み状態）

#### 現在のVaultにあるファイル

| 保存メタ | 実ファイル | リモートファイル | アクション |
|:--------:|:----------:|:----------------:|--------|
| A | A | 存在 | スキップ（変更なし） |
| A | B | 存在 | **アップロード**（ローカル変更） |
| - | A | なし | **アップロード**（新規ファイル） |
| - | A | 存在 | **アップロード**（リモート上書き） |

#### ローカルで削除されたファイル

| 保存メタ | 実ファイル | リモートファイル | アクション |
|:--------:|:----------:|:----------------:|--------|
| A | - | 存在 | スキップ（リモートに「未追跡」として残る） |

### 重要事項

- Pushはリモートファイルを**削除しない**
- 削除されたローカルファイルはリモートで「未追跡」になる（復元可能）
- 設定の「未追跡ファイルを検出」で管理可能

---

## Pull Changes（差分）

変更されたファイルのみリモートからローカルにダウンロードします。

### フロー

1. **前提条件チェック**
   - リモートメタなし → Pullするものなし
   - ローカルメタなし → 全リモートファイルをダウンロード

2. **差分計算**（各ファイル）
   - 比較: ローカルメタ vs リモートメタ vs 実ファイル

3. **競合処理**（あれば）
   - diff表示付き競合ダイアログを表示

4. **変更ファイルをダウンロード**

5. **リモートから削除されたファイルをローカルで削除**

### 判定表

#### 両メタにあるファイル

| ローカルメタ | リモートメタ | 実ファイル | アクション |
|:----------:|:-----------:|:-----------:|--------|
| A | A | A | スキップ（変更なし） |
| A | A | B | スキップ（ローカルのみ変更、次Pushでアップ） |
| A | A | - | スキップ（ローカル削除、次Push時に反映） |
| A | B | A | **ダウンロード**（リモート変更） |
| A | B | B | **競合**（両方変更） |
| A | B | C | **競合**（両方が異なる値に変更） |
| A | B | - | **ダウンロード**（ローカル削除＋リモート変更） |

#### ローカルメタのみ（リモートから削除）

| ローカルメタ | リモートメタ | 実ファイル | アクション |
|:----------:|:-----------:|:-----------:|--------|
| A | - | A | **ローカル削除**（リモートで削除済み） |
| A | - | B | **競合**（ローカル変更＋リモート削除） |
| A | - | - | なにもしない（既に両方で削除済み） |

#### リモートメタのみ（新規リモートファイル）

| ローカルメタ | リモートメタ | 実ファイル | アクション |
|:----------:|:-----------:|:-----------:|--------|
| - | A | - | **ダウンロード**（新規リモートファイル） |
| - | A | A | スキップ（同一内容、メタ更新のみ） |
| - | A | B | **競合**（ローカル新規＋リモート新規で異なる） |

### この方式の利点

- **誤った競合を回避**: ローカルのみ変更は競合にならない
- **安全な上書き**: リモートが実際に変更された場合のみダウンロード
- **明確な分離**: Pushはアップロード、Pullはダウンロードを担当
- **削除を正しく処理**: 意図的な削除を尊重しつつ競合を検出

---

## Full Push

Vault全体をアップロードし、古いリモートバージョンを保持します。

### フロー

各ローカルファイルについて:

1. リモートとハッシュを比較
2. **同じ** → スキップ（変更不要）
3. **異なる** → リモートファイルをリネーム（タイムスタンプ追加） → 新バージョンをアップロード

### 判定表

| ローカル | リモートファイル | リモートメタ | ハッシュ | アクション |
|:--------:|:----------------:|:-----------:|:--------:|--------|
| A | 存在 | hash=A | 同じ | スキップ（変更なし） |
| B | 存在 | hash=A | 異なる | リモートをリネーム → **アップロード** B |
| A | 存在 | - | - | **アップロード** A |
| A | なし | - | - | **アップロード** A |

### 例

- ローカル: `notes/daily.md` ≠ リモート: `notes/daily.md`
- → リモートをリネーム: `notes/daily_20240124_103000.md`（未追跡になる）
- → ローカルをアップロード: `notes/daily.md`

### 復元方法

古いバージョンは「未追跡」になり:
- **復元**: 設定 → 未追跡ファイルを検出 → 選択を復元
- **削除**: 設定 → 未追跡ファイルを検出 → 選択を削除

---

## Full Pull

Vault全体をダウンロードし、古いローカルバージョンを保持します。

### フロー

各リモートファイルについて:

1. ローカルとハッシュを比較
2. **同じ** → スキップ（変更不要）
3. **異なる** → ローカルを`sync_conflicts/`に保存 → リモートバージョンをダウンロード

### 例

- ローカル: `notes/daily.md` ≠ リモート: `notes/daily.md`
- → ローカルを保存: `sync_conflicts/daily_20240124_103000.md`
- → リモートをダウンロード: `notes/daily.md`

### 復元方法

古いローカルバージョンは`sync_conflicts/`フォルダに保存:
- フォルダを参照してバックアップファイルを確認
- 設定 → 競合ファイルを削除で一括削除

---

## 競合解決

競合は**Pull**の時のみ発生します。ローカルとリモートの両方で同じファイルが変更された場合、ダイアログが表示されます:

- 両バージョンのファイルパスとタイムスタンプ
- マークダウンファイルは**差分を表示**ボタン（Side-by-side比較）
- **ローカルを保持** / **リモートを保持** ボタン

| 選択 | 動作 |
|------|------|
| **ローカルを保持** | ローカルをアップロード、リモートを`sync_conflicts/`に保存 |
| **リモートを保持** | リモートをダウンロード、ローカルを`sync_conflicts/`に保存 |

選択されなかったバージョンは常にバックアップされ、必要に応じて手動マージできます。

---

## ファイルの復元

### シナリオ1: 競合 - 両方のバージョンが必要

競合が発生した場合、「ローカルを保持」か「リモートを保持」を選びますが、選ばなかった方は常に`sync_conflicts/`に保存されます。

**手動マージの方法:**
1. 保持したファイルを開く
2. `sync_conflicts/`フォルダでもう一方のバージョンを探す
3. バックアップから必要な部分をコピー
4. 完了したらバックアップファイルを削除

### シナリオ2: 後から削除したファイルが必要になった

ローカルでファイルを削除してPushした場合、ファイルはGoogle Drive上に「未追跡」として残ります。

**復元方法:**
1. 設定 → 未追跡ファイルを検出
2. 必要なファイルを選択
3. 「選択を復元」をクリック

### シナリオ3: ローカルで誤って変更・削除した

ローカルで誤ってファイルを変更・削除してしまい、リモートから復元したい場合。

**復元方法:** **Full Pull**を使用 - リモートを正として差分のあるファイルをダウンロードします。差分のあったローカルファイルは`sync_conflicts/`にバックアップされるので、上書きされたくないファイルも後から戻せます。

---

## 設定

![設定画面](settings.png)

| 設定 | 説明 |
|------|------|
| Exclude patterns | 除外するglobパターン |
| Conflict folder | バックアップフォルダ名（デフォルト: `sync_conflicts`） |
| Clear conflict files | バックアップファイルを一括削除 |
| Detect Untracked Files | 未追跡リモートファイルの検出・復元・削除 |
| Full Push | Vault全体をアップロード |
| Full Pull | Vault全体をダウンロード |

### デフォルト除外パターン

- `.obsidian/**` - Obsidian設定
- `.**` - ドットファイル
- `.*/**` - ドットフォルダ
- `sync_conflicts/**` - バックアップフォルダ

---

## FAQ

### モバイルで動作しますか？

はい！AndroidとiOSで動作します。

### Vault名はデバイス間で一致させる必要がありますか？

はい。プラグインはVault名で同期対象を識別します。

### Google Driveに直接ファイルを追加できますか？

いいえ。プラグインは自身が作成したファイルのみアクセス可能（Google API制限）。

### なぜファイルがGoogle Driveでフラットに保存されるのですか？

実装がシンプルになるためです。フォルダ構造は`folder/note.md`のようなファイル名で保持されます。

### ファイルを除外するには？

設定でglobパターンを追加:
- `*.tmp` - .tmpファイルを除外
- `drafts/**` - draftsフォルダを除外
- `**/private/**` - 「private」フォルダを除外

---

## トラブルシューティング

1. プラグインが有効か確認
2. Refresh Tokenが正しいか確認
3. インターネット接続を確認
4. コンソールでエラーメッセージを確認（Ctrl+Shift+I）

## サポート

- [GitHub Issues](https://github.com/takeshy/obsidian-gdrive-vault/issues)

## ライセンス

MIT
